[[coordinate-types, Chapter 4, Coordinate Types]]
==  Coordinate Types
:doc-part: 4
:figure: 0

The commonest use of coordinate variables is to locate the data in space and time, but coordinates may be provided for any other continuous geophysical quantity (e.g. density, temperature, radiation wavelength, zenith angle of radiance, sea surface wave frequency) or discrete category (see <<discrete-axis>>, e.g. area type, model level number, ensemble member number) on which the data variable depends.

Four types of coordinates receive special treatment by these conventions: latitude, longitude, vertical, and time.
We continue to support the special role that the **`units`** and **`positive`** attributes play in the COARDS convention to identify coordinate type.
As an extension to COARDS, we strongly recommend that a parametric (usually dimensionless) vertical coordinate variable should be associated, via **`standard_name`** and **`formula_terms`** attributes, with its explicit definition, which provides a mapping between its values and dimensional vertical coordinate values that can be uniquely located with respect to a point on the earth's surface.

Because identification of a coordinate type by its units is complicated by requiring the use of an external package <<UDUNITS>>, we provide two optional methods that yield a direct identification.
The attribute **`axis`** may be attached to a coordinate variable and given one of the values **`X`**, **`Y`**, **`Z`** or **`T`** which stand for a longitude, latitude, vertical, or time axis respectively.
Alternatively the **`standard_name`** attribute may be used for direct identification.
But note that these optional attributes are in addition to the required COARDS metadata.

To identify generic spatial coordinates we recommend that the **`axis`** attribute be attached to these coordinates and given one of the values **`X`**, **`Y`** or **`Z`**.
The values **`X`** and **`Y`** for the axis attribute should be used to identify horizontal coordinate variables.
If both X- and Y-axis are identified, **`X-Y-up`** should define a right-handed coordinate system, i.e. rotation from the positive X direction to the positive Y direction is anticlockwise if viewed from above.
We strongly recommend that coordinate variables be used for all coordinate types whenever they are applicable.

The methods of identifying coordinate types described in this section apply both to coordinate variables and to auxiliary coordinate variables named by the **`coordinates`** attribute (see <<coordinate-system>>).

The values of a coordinate variable or auxiliary coordinate variable indicate the locations of the gridpoints.
The locations of the boundaries between cells are indicated by bounds variables (see <<cell-boundaries>>).

[[latitude-coordinate, Section 4.1, "Latitude Coordinate"]]
=== Latitude Coordinate

Variables representing latitude must always explicitly include the **`units`** attribute; there is no default value.
The recommended value of the **`units`** attribute is the string **`degrees_north`**. Also accepted are **`degree_north`**, **`degree_N`**, **`degrees_N`**, **`degreeN`**, and **`degreesN`**.

[[latitude-axis-ex]]
[caption="Example 4.1. "]
.Latitude axis
====

----

float lat(lat) ;
  lat:long_name = "latitude" ;
  lat:units = "degrees_north" ;
  lat:standard_name = "latitude" ;

----

====

Application writers should note that the UDUNITS package does not recognize the directionality implied by the "north" part of the unit specification.
It only recognizes its size, i.e., 1 degree is defined to be pi/180 radians.
Hence, determination that a coordinate is a latitude type should be done via a string match between the given unit and one of the acceptable forms of **`degrees_north`**.


Optionally, the latitude type may be indicated additionally by providing the **`standard_name`** attribute with the value **`latitude`**, and/or the **`axis`** attribute with the value **`Y`**.

Coordinates of latitude with respect to a rotated pole should be given units of **`degrees`**, not **`degrees_north`** or equivalents, because applications which use the units to identify axes would have no means of distinguishing such an axis from real latitude, and might draw incorrect coastlines, for instance.

[[longitude-coordinate, Section 4.2, "Longitude Coordinate"]]
=== Longitude Coordinate

Variables representing longitude must always explicitly include the **`units`** attribute; there is no default value.
The recommended value of the **`units`** attribute is the string **`degrees_east`**. Also accepted are **`degree_east`**, **`degree_E`**, **`degrees_E`**, **`degreeE`**, and **`degreesE`**.



[[longitude-axis-ex]]
[caption="Example 4.2. "]
.Longitude axis
====

----

float lon(lon) ;
  lon:long_name = "longitude" ;
  lon:units = "degrees_east" ;
  lon:standard_name = "longitude" ;

----

====

Application writers should note that the UDUNITS package has limited recognition of the directionality implied by the "east" part of the unit specification.
It defines **`degrees_east`** to be pi/180 radians, and hence equivalent to **`degrees_north`**.
We recommend the determination that a coordinate is a longitude type should be done via a string match between the given unit and one of the acceptable forms of **`degrees_east`**.

Optionally, the longitude type may be indicated additionally by providing the **`standard_name`** attribute with the value **`longitude`**, and/or the **`axis`** attribute with the value **`X`**.

Coordinates of longitude with respect to a rotated pole should be given units of **`degrees`**, not **`degrees_east`** or equivalents, because applications which use the units to identify axes would have no means of distinguishing such an axis from real longitude, and might draw incorrect coastlines, for instance.

[[vertical-coordinate, Section 4.3, "Vertical Coordinate"]]
=== Vertical (Height or Depth) Coordinate

Variables representing dimensional height or depth axes must always explicitly include the **`units`** attribute; there is no default value.

The direction of positive (i.e., the direction in which the coordinate values are increasing), whether up or down, cannot in all cases be inferred from the units.
The direction of positive is useful for applications displaying the data.
For this reason the attribute **`positive`** as defined in the COARDS standard is required if the vertical axis units are not a valid unit of pressure (as determined by the UDUNITS package <<UDUNITS>>) -- otherwise its inclusion is optional.
The **`positive`** attribute may have the value **`up`** or **`down`** (case insensitive).
This attribute may be applied to either coordinate variables or auxiliary coordinate variables that contain vertical coordinate data.

For example, if an oceanographic netCDF file encodes the depth of the surface as 0 and the depth of 1000 meters as 1000 then the axis would use attributes as follows: 

----
axis_name:units = "meters" ; 
axis_name:positive = "down" ; 	
----

If, on the other hand, the depth of 1000 meters were represented as -1000 then the value of the **`positive`** attribute would have been **`up`**.
If the **`units`** attribute value is a valid pressure unit the default value of the **`positive`** attribute is **`down`**.

A vertical coordinate will be identifiable by:

* units of pressure; or
* the presence of the **`positive`** attribute with a value of **`up`** or **`down`** (case insensitive).

Optionally, the vertical type may be indicated additionally by providing the **`standard_name`** attribute with an appropriate value, and/or the **`axis`** attribute with the value **`Z`**. 
If both **`positive`** and **`standard_name`** are provided, it is recommended that they should be consistent. 
For instance, if a depth of 1000 metres is represented by -1000 and **`positive`** is **`up`**, it would be inconsistent to give the **`standard_name`** as **`depth`**, whose definition (vertical distance below the surface) implies positive down. 
If an application detects such an inconsistency, the user should be warned, and the **`positive`** attribute should be used to determine the sign convention.

==== Dimensional Vertical Coordinate


Variables representing dimensional vertical coordinates for depth or height must always explicitly include the **`units`** attribute.
The acceptable units for a vertical (depth or height) coordinate variable must a UDUNITS <<UDUNITS>> representation of one of the following:

* units of pressure.
For vertical axes the most commonly used of these include **`bar`**, **`millibar`**, **`decibar`**, **`atmosphere (atm)`**, **`pascal (Pa)`**, and **`hPa`**.
* units of length.
For vertical axes the most commonly used of these include **`meter (metre, m)`**, and **`kilometer (km)`**.
* other units that may under certain circumstances reference vertical position such as units of density or temperature.

Plural forms are also acceptable.

[[dimensionless-vertical-coordinate, Section 4.3.2, "Dimensionless Vertical Coordinate"]]
==== Dimensionless Vertical Coordinate

The **`units`** attribute is not required for dimensionless coordinates.
For backwards compatibility with COARDS we continue to allow the **`units`** attribute to take one of the values: **`level`**, **`layer`**, or **`sigma_level`**.
These values are not recognized by the UDUNITS package, and are considered a deprecated feature in the CF standard.

[[parametric-vertical-coordinate, Section 4.3.3, "Parametric Vertical Coordinate"]]
==== Parametric Vertical Coordinate

In some cases dimensional vertical coordinates are a function of horizontal location as well as parameters which depend on vertical location, and therefore cannot be stored in the one-dimensional vertical coordinate variable, which is in most of these cases is dimensionless.
The `standard_name` of the parametric (usually dimensionless) vertical coordinate variable can be used to find the definition of the associated computed (always dimensional) vertical coordinate in <<parametric-v-coord>>.
The definition provides a mapping between the parametric vertical coordinate values and computed values that can positively and uniquely indicate the location of the data.
The `formula_terms` attribute can be used to associate terms in the definitions with variables in a netCDF file, and the `computed_standard_name` attribute can be used to supply the `standard_name` of the computed vertical coordinate values computed according to the definition.
To maintain backwards compatibility with COARDS the use of these attributes is not required, but is strongly recommended.
Some of the definitions may be supplemented with information stored in the `grid_mapping` variable about the datum used as a vertical reference (e.g. geoid, other geopotential datum or reference ellipsoid; see <<grid-mappings-and-projections>> and <<appendix-grid-mappings>>).

[[atm-sigma-coord-ex]]
[caption="Example 4.3. "]
.Atmosphere sigma coordinate
====

----
float lev(lev) ;
  lev:long_name = "sigma at layer midpoints" ;
  lev:positive = "down" ;
  lev:standard_name = "atmosphere_sigma_coordinate" ;
  lev:formula_terms = "sigma: lev ps: PS ptop: PTOP" ;
  lev:computed_standard_name = "air_pressure" ;
----

====

In this example the **`standard_name`** value **`atmosphere_sigma_coordinate`** identifies the following definition from <<parametric-v-coord>> which specifies how to compute pressure at gridpoint **`(n,k,j,i)`** where **`j`** and **`i`** are horizontal indices, **`k`** is a vertical index, and **`n`** is a time index:

----
p(n,k,j,i) = ptop + sigma(k)*(ps(n,j,i)-ptop)
----

The **`formula_terms`** attribute associates the variable **`lev`** with the term **`sigma`**, the variable **`PS`** with the term **`ps`**, and the variable **`PTOP`** with the term **`ptop`**.
Thus the pressure at gridpoint **`(n,k,j,i)`** would be calculated by 

----
p(n,k,j,i) = PTOP + lev(k)*(PS(n,j,i)-PTOP)
----

The `computed_standard_name` attribute indicates that the values in variable
`p` would have a `standard_name` of `air_pressure`.


[[time-coordinate, Section 4.4, "Time Coordinate"]]
=== Time Coordinate

A time coordinate is a number which identifies an instant along the continuous axis of time, expressed as elapsed time relative to a specified reference instant.
Variables containing time coordinates have a **`units`** attribute (see <<time-coordinate-variables>> and <<time-coordinate-units>>, e.g. **`units="days since 1990-1-1 0:0:0"`**) which defines both the unit of measure of elapsed time (here **`days`**) and the reference instant (here **`1990-1-1 0:0:0`**).

The interpretation of the numeric values as dates and times depends on both the **`units`** attribute and the calendar, specified by the **`calendar`** attribute.
Given the **`units`** and **`calendar`**, a time coordinate value and its corresponding representation as a date and time are interconvertible.
CF defines several different calendars (see <<calendar>>) to meet diverse requirements, both for the real world and for models.

In reality, the need for explicit calendar definitions arises in part because the natural astronomical periods of year and day, which are based on the Earth's orbit and rotation, are not constants and do not align exactly.
A year is not an integer multiple of days, the length of a day varies with changes in Earth's rotation, and the timing of seasons within the astronomical year is affected by the precession of the equinoxes.
Calendars introduce an extra day (a "leap day", in leap years) to keep their annual cycles aligned with the astronomical year, and leap seconds are occasionally inserted into Coordinated Universal Time (link:$$https://en.wikipedia.org/wiki/Coordinated_Universal_Time$$[UTC]) to maintain agreement with observed rotation.
Some CF real-world calendars either explicitly omit leap seconds or tacitly assume they are ignored (see <<calendar>>).

In addition to real-world calendars, CF defines several simplified calendars that are widely used in numerical models including, for example, the **`360_day`** calendar (with twelve 30-day months) and the **`366_day`** calendar (with a leap day every year).
These calendars consistently represent the lengths of days and years in those models, where the astronomical cycles are themselves simplified.


[[time-coordinate-variables, Section 4.4.1, "Time Coordinate Variables"]]
==== Time Coordinate Variables

Variables containing time coordinates must always explicitly include the **`units`** attribute, formatted as described in <<time-coordinate-units>>.
There is no default value for the **`units`**.
A coordinate variable is identifiable as a time coordinate variable from its **`units`** alone.
Optionally, a time coordinate variable may be indicated additionally by providing the **`standard_name`** attribute with an appropriate value, and/or the **`axis`** attribute with the value **`T`**.

[[time-axis-ex]]
[caption="Example 4.4. "]
.Example of a time coordinate variable
====

----
double time(time) ;
  time:axis = "T" ;                          // axis attribute is optional
  time:standard_name = "time" ;              // standard_name attribute is optional
  time:calendar = "standard" ;               // calendar attribute is recommended
  time:units = "days since 1990-1-1 0:0:0" ; // units attribute is mandatory
----

====


[[time-coordinate-units, Section 4.4.2, "Time Coordinate Units"]]
==== Time Coordinate Units

The **`units`** attribute of a time coordinate variable takes a string value that follows the formatting requirements of the <<UDUNITS>> package (e.g. <<time-axis-ex>>).
It must comprise a unit of measure that is physically equivalent (see <<units>>) to the SI base unit of time (i.e. the second), followed by the word **`since`** and a reference datetime, in the format specified below.
The time coordinate exactly equals the length of the time interval from the instant identified by the reference datetime to the instant identified by the time coordinate, in all cases except when leap seconds occur between the two instants in the **`standard`** calendar.
(See <<appendix-leap-seconds>> for details.)

The CF standard follows UDUNITS (<<units>>) in the definition of the acceptable units of measure for time.
The most commonly used of these units (and their symbols) are **`day`** (**`d`**), **`hour`** (**`h`**), **`minute`** (**`min`**) and **`second`** (**`s`**).
Plural forms are also acceptable.
In CF, following UDUNITS, any unit may optionally have one of the decimal prefixes for multiples and submultiples (<<table-supported-units, Table 3.1>>) e.g. **`millisecond`** or **`ms`**.
CF recommends __not__ to use these prefixes with any unit of time other than **`second`**, because <<SI>> (chapter 4) does not allow them except with **`second`**.

UDUNITS defines a **`year`** to be exactly 365.242198781 days (the interval between 2 successive passages of the sun through vernal equinox).
__It is not a calendar year.__ UDUNITS defines a **`month`** to be exactly **`year/12`**, which is __not a calendar month__.
We recommend that **`year`** and **`month`** should not be used, because of the potential for mistakes and confusion.

UDUNITS defines a **`minute`** as 60 **`seconds`**, an **`hour`** as 3600 **`seconds`** and a **`day`** as 86400 **`seconds`**, consistent with the <<SI>> definitions of these non-SI units.
These are fixed units of measure.
When a leap second is inserted into UTC, the minute, hour and day affected differ by one second from their usual durations according to clock time, but the units of **`minute`**, **`hour`** and **`day`** do not.
To avoid mistakes and confusion, we therefore recommend that these units should not be used in the **`utc`** calendar (<<calendar>>).

UDUNITS permits a number of alternatives to the word **`since`** in the units of time coordinates.
All the alternatives have exactly the same meaning in UDUNITS.
For compatibility with other software, CF strongly recommends that **`since`** should be used.

The reference datetime string (appearing after the identifier **`since`**) is required.
Its format is __y__-__m__-__d__ [__H__:__M__:__S__[ __T__]], where [...] indicates an optional element, as follows:

* __y__ is year, __m__ month, __d__ day, __H__ hour and __M__ minute, which are all integers of one or more digits, and __y__ may be prefixed with a sign (but note that some CF calendars do not permit negative years; see <<calendar>>),

* __S__ is second, which may be integer or floating point,

* __T__ is the time zone offset.
__T__ is __not__ a time zone name or acronym; it is an interval of time.

The default for time zone offset __T__ is zero, which may also be explicitly indicated in any of the numeric formats for __T__ defined below, or by the letter **`Z`**, sometimes referred to as "Zulu Time".
We suggest that a zero offset be stated explicitly to avoid confusion in situations where omitting it might be misunderstood as indicating local time.
We recommend that a non-zero time zone offset should __not__ be specified __in any situation__, because it is easy to make mistakes about the sign of the offset and allowance for daylight-saving/summer time.
A non-zero offset is __not allowed__ in the **`utc`** and **`tai`** calendars (see <<calendar>>).

In a time zone with zero offset, time (approximately) equals mean solar time for 0 **`degrees_east`** of longitude.
If both time and time zone offset are omitted the time is 00:00:00 (the beginning of the day i.e. midnight in the time zone with zero offset).
Thus, **`units = "days since 1990-1-1"`** means the same as **`units = "days since 1990-1-1 00:00:00Z"`**.

Other than **`Z`** for zero offset, the time zone offset __T__ must be in one of the following signed numeric formats, where &pm; stands for the positive sign **`+`** or the negative sign **`-`**, and __n__ stands for a single digit.

* &pm;__n__ or &pm;__nn__, the hour alone, of one or two digits e.g. **`-6`**, **`+2`**, **`+11`**. This format is sufficient for many time zones. Zero hours must have a positive sign e.g. **`+0`**, which means the same as **`Z`**.

* &pm;__n__:__nn__ or &pm;__nn__:__nn__, the hour and minute, separated by a colon **`:`**, where the hour is one or two digits, and the minute is two digits e.g. **`-10:00`**, **`-3:30`**, **`+5:30`**, **`+12:45`**.

Spaces are not allowed in the numeric formats.
The space between the time and __T__ may be omitted.

For example, **`1992-10-8 15:15:42.5`** indicates 42.5 seconds after 3.15 pm on 8th October 1992, in the time zone with zero offset.
Subtracting the time zone offset from a given datetime converts it to the equivalent datetime with zero time zone offset e.g. **`1992-10-8 09:15:42.5 -6`** identifies the same instant as **`1992-10-8 15:15:42.5`**.


[[calendar, Section 4.4.3, "Calendar"]]
==== Calendar

A calendar defines a set of valid datetimes and their order; note that the CF meaning of "calendar" refers to datetimes, not to dates alone.
It is recommended that the time coordinate variable should have a **`calendar`** attribute (rather than relying on the default).
<<table-calendars, Table 4.1>> lists the possible values of the **`calendar`** attribute and the key characteristics of the calendars.

====
[[table-calendars]]
.List of defined values for the **`calendar`** attribute and summary of the key characteristics of the calendars
[options="header",caption="Table 4.1. ",cols="20,8,22,8,8,10,10"]
|===============
| **`calendar`** | Days in year | Leap days | Leap seconds | Exact intervals | First date | Last date
| **`standard`** before CF 1.13 .2+| 365/366 .2+| Julian before 1582-10-05
Gregorian from 1582-10-15 | unknown | unknown .2+| 0001-01-01 .2+| +&#x221E;
| **`standard`** since CF 1.13 | no | some
| **`julian`** | 365/366 | Julian | no | all | 0001-01-01 | +&#x221E;
| **`proleptic_gregorian`** | 365/366 | Gregorian | no | all | -&#x221E; | +&#x221E;
| **`no_leap`**/**`365_day`** | 365 | never | no | all | -&#x221E; | +&#x221E;
| **`all_leap`**/**`366_day`** | 366 | every year | no | all | -&#x221E; | +&#x221E;
| **`360_day`** | 360 | never | no | all | -&#x221E; | +&#x221E;
| **`utc`** | 365/366 | Gregorian | yes | all | 1972-01-01 | today
| **`tai`** | 365/366 | Gregorian | no | all | 1958-01-01 | +&#x221E;
|===============
In this table, "/" means "or", "-&#x221E;" means "any date (provided it is earlier than the **Last date**, if any)" and "+&#x221E;" means "any date (provided it is later than the **First date**, if any)".
As well as those listed in this table, the **`calendar`** attribute may also take the value **`none`** or any other value, with meanings given at the end of <<calendar>>.
In the **Leap days** column, "Gregorian" and "Julian" identify different rules for determining whether a given year is a common year (with 365 days) or a leap year (with 366).
By the Gregorian rule, a year is a leap year if either (i) it is divisible by 4 but not by 100 or (ii) it is divisible by 400.
By the Julian rule, any year that is divisible by 4 is a leap year, even if it is also divisible by 100.
In the **Leap seconds** column: "no" means that seconds &ge;60 are not allowed in datetimes, and that time coordinates and datetimes must be interconverted assuming 60 seconds in every minute, as if leap seconds never occurred; "yes" means that datetimes with seconds &ge;60 are valid and must be counted in time coordinates.
In the **Exact intervals** column: "all" means that the difference between two time coordinates __always__ exactly equals the interval between the instants they identify; "some" means this is __not always__ true.
====

The lengths of the months defined by the Julian and Gregorian calendars (12 months in the year, 31 days in January, etc.) are used in all calendars except **`360_day`** (in which there are 12 months of 30 days each), **`none`** (see <<none-calendar>>) and explicitly defined calendars (see <<explicit-calendar>>).
The calendars differ in their treatment of leap years (when there are 29 days in February instead of 28).

In a given calendar, each valid datetime identifies a particular instant in the continuous physical dimension of time.
The reference datetime in the **`units`** of a time coordinate variable must be a valid datetime in the calendar of the variable, and identifies a particular instant according to that calendar.
A datetime which is invalid in a given calendar cannot be converted into a time coordinate value in that calendar.
For example, 2025-01-31 00:00 is a valid datetime in the **`standard`** calendar but not in the **`360_day`** calendar (in which January has 30 days), while 2025-02-29 11:00 is valid in the **`all_leap`** calendar (in which 2025 is a leap year) but not in the **`standard`** calendar.

A given instant in the continuous physical dimension of time may be identified by different datetimes in different calendars.
For example, 1917-11-07 12:00 in the **`standard`** calendar and 1917-10-25 12:00 in the **`julian`** calendar identify the same instant.
Because the calendars have different sets of valid datetimes, a given time coordinate value with given reference datetime in its **`units`** can represent different datetimes in different calendars.
For example, a time coordinate of **1** with **`units="days since 2020-02-28 23:10"`** represents the datetime 2020-02-29 23:10 in the **`standard`** calendar, but 2020-03-01 23:10 in the **`no_leap`** calendar (in which 2020 is not a leap year).

In all calendars __except__ **`julian`** and **`standard`**, year 0 is the year before year 1, and negative years are allowed.
In the **`julian`** and **`standard`** calendars, dates in years before year 0 are invalid and must not be used in the reference datetime of the **`units`** attribute.
In these calendars, datetimes in year 0 indicate a climatology.
This use is deprecated (see <<climatological-statistics>> for the recommended mechanism).

Since 1972-01-01, UTC has been the basis of civil time internationally, and the definition of the time zone with zero offset, which is the default time zone in UDUNITS and CF (see <<time-coordinate-units>>).
Owing to variations in Earth rotation, positive or negative leap seconds are inserted into UTC in order to keep it close to mean solar time at 0 **`degrees_east`**.
When a single positive leap second is inserted at the end of a minute, that minute contains 61 seconds.
The net number of leap seconds added to UTC between 1972-01-01 and 2025-01-01 is 27.

If you are producing a dataset which follows the Gregorian calendar, the recommended choice of CF **`calendar`** is as follows:

* Use the **`utc`** calendar for observational data for datetimes since 1972 based on UTC, if it is necessary to preserve precision to the second in both datetimes and time intervals.

WARNING: The **`utc`** calendar requires both the writer **and the user** of the dataset to have software that takes leap seconds into account for converting between datetimes and time coordinates.
Leap seconds are ignored by most software, including UDUNITS.

* Use the **`tai`** calendar for observational data with TAI datetimes.

* Use the **`standard`** calendar for observational data in other cases.

* Use the **`proleptic_gregorian`** calendar for model-generated data.
(In principle a model could be programmed to include leap seconds, but we assume that this is not the case.)

<<appendix-leap-seconds>> compares these calendars' treatment of leap seconds and explains the above recommendations.
Leap seconds do not need to be considered in the **`360_day`**, **`365_day`** and **`366_day`** calendars.

Further details of each calendar are as follows:

**`standard`**:: The Gregorian--Julian calendar as defined by UDUNITS.
This is the default calendar when there is no **`calendar`** attribute, except when the attribute `month_lengths` is present (see <<explicit-calendar>>).
A deprecated alternative name for this calendar is **`gregorian`**.
The Gregorian and Julian calendars have the same lengths of their months; they differ only in respect of the rules that decide which years are leap years.
In the **`standard`** calendar, datetimes after, and including, 1582-10-15 0:0:0 follow the Gregorian rule for leap years.
Datetimes before, and excluding, 1582-10-5 0:0:0 follow the Julian rule for leap years.
Year 1 AD or CE in the **`standard`** calendar is also year 1 of the **`julian`** calendar.
Negative years are invalid in time coordinates and reference datetimes in the **`standard`** calendar.
+
In the **`standard`** calendar, datetimes in the range from (and including) 1582-10-5 0:0:0 until (but excluding) 1582-10-15 0:0:0 are invalid.
Datetimes in this range must not be used as reference in **`units`**.
The interval between the datetimes 1582-10-4 0:0:0 and 1582-10-15 0:0:0 is exactly 1 day.
It is recommended that a reference datetime before the discontinuity should not be used for datetimes after the discontinuity, and vice-versa.
+
The **`standard`** calendar has been used for both observational data and model-generated data with real-world datetimes.
In data written with CF versions before 1.13 in the **`standard`** calendar for dates since 1972, datetimes and time coordinates should be regarded as uncertain by a number of seconds (but less than a minute), because leap seconds may or may not have been taken into account.
For such datasets, this uncertainty can be eliminated only if you have separate information about how leap seconds were treated.
+
In real-world data written with CF 1.13 or later in the **`standard`** calendar,

* datetimes since 1972 are UTC,

* the difference between two time coordinates is less than the length of the time interval between them by the number of intervening leap seconds.

+
See <<appendix-leap-seconds>> for details.

**`proleptic_gregorian`**:: A calendar with the Gregorian rule for leap years, extended to dates before 1582-10-15.
All dates consistent with these rules are allowed, both before and after 1582-10-15 0:0:0.
There are no leap seconds in this CF calendar.

**`julian`**:: A calendar which follows the Julian rule for leap years.
Year 1 AD or CE in the **`julian`** calendar is also year 1 of the **`standard`** calendar.
Negative years are invalid in time coordinates and reference datetimes in the **`julian`** calendar.

**`utc`**:: A Gregorian calendar __with leap seconds__ prescribed by UTC.
Earlier datetimes than 1972-01-01 00:00 are not allowed in the UTC calendar, whose current definition came into force at that instant.
The same instant has the datetime 1972-01-01 00:00:10 in the **`tai`** calendar.
The difference of 10 seconds between these datetimes is an adjustment for variations in Earth rotation between 1958-01-01 00:00:00, when TAI began, and 1972-01-01 00:00.
The difference (**`tai`** minus **`utc`**) between the datetimes for any subsequent instant is 10 seconds plus the net number of leap seconds introduced since 1972-01-01.
A given datetime in the **`utc`** calendar represents an instant that is later than the same datetime in the **`tai`** calendar.
Datetimes in the future are not allowed in this calendar, because it is unknown when future leap seconds will occur.
+
To avoid mistakes and confusion, the second is the only recommended unit of measure in this **`calendar`** for the **`units`** of the time coordinate variable (denoted by any string allowed in UDUNITS, optionally with one of the prefixes of <<table-supported-units, Table 3.1>>).
For the same reason, it is recommended not to use a datetime during a leap second as the reference datetime in the **`units`** attribute.
When a datetime is converted to a time coordinate value or vice-versa in this calendar, any leap seconds (positive or negative) must be counted that occurred in the interval between the datetime and the reference datetime in the **`units`**.
If time coordinates in the **`utc`** calendar are converted to datetimes by software that does not take leap seconds into account, they will be later than the correct UTC datetimes by a number of seconds.
+
A non-zero time zone offset is not allowed in this calendar.

**`tai`**:: A Gregorian calendar __without leap seconds__ that is based on International Atomic Time (TAI), which began on 1958-01-01 0:0:0.
Earlier datetimes than this are not allowed in the **`tai`** calendar.
The difference between the two datetimes (**`tai`** minus **`utc`**) for a given instant of time is 10 seconds plus the net number of leap seconds introduced since the instant with the datetime 1972-01-01 00:00:10 in the **`tai`** calendar, when the current definition of UTC came into force.
The same instant has the datetime 1972-01-01 00:00:00 in the **`utc`** calendar.
A given datetime in the **`tai`** calendar represents an instant that is earlier than the same datetime in the **`utc`** calendar.
A non-zero time zone offset is not allowed in this calendar.

**`noleap`** or **`365_day`**:: A model calendar with no leap years, i.e., all years are 365 days long.

**`all_leap`** or **`366_day`**:: A model calendar in which every year is a leap year, i.e., all years are 366 days long.

**`360_day`**:: A model calendar in which all years are 360 days, and divided into 30 day months.

**`none`**:: To be used when there is no annual cycle.
See <<none-calendar>>.

Any other value may be given to the **`calendar`** attribute to describe an explicitly defined calendar.
See <<explicit-calendar>>.


[[none-calendar, Section 4.4.5, "Time Coordinates with no Annual Cycle"]]
==== Time Coordinates with no Annual Cycle

The **`calendar`** attribute may be set to **`none`** in climate experiments that simulate a fixed time of year.
The time of year is indicated by the date in the reference time of the **`units`** attribute.
The time coordinates that might apply in a perpetual July experiment are given in the following example.

[[perpetual-time-axis-ex]]
[caption="Example 4.5. "]
.Perpetual time axis
====

----
variables:
  double time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1-7-15 0:0:0" ;
    time:calendar = "none" ;
data:
  time = 0., 1., 2., ...;
----

====

Here, all days simulate the conditions of 15th July, so it does not make sense to give them different dates.
The time coordinates are interpreted as 0, 1, 2, etc. days since the start of the experiment.


[[explicit-calendar, Section 4.4.6, "Explicitly Defined Calendar"]]
==== Explicitly Defined Calendar

If none of the calendars defined in <<calendar>> applies (e.g., calendars appropriate to a different paleoclimate era), a calendar can be explicitly defined, in terms of permissible year-month-day combinations.
To do this, the lengths of each month are explicitly defined with the **`month_lengths`** attribute of the time axis:

**`month_lengths`**:: A vector of size 12, specifying the number of days in the months from January to December (in a non-leap year).

If leap years are included, then two other attributes of the time axis must also be defined:

**`leap_year`**:: An example of a leap year.
It is assumed that all years that differ from this year by a multiple of four are also leap years.
If this attribute is absent, it is assumed there are no leap years.

**`leap_month`**:: A value in the range 1-12, specifying which month is lengthened by a day in leap years (1=January).
If this attribute is not present, February (2) is assumed.
This attribute is ignored if **`leap_year`** is not specified.

When an explicitly defined calendar is being used, the calendar may be described by giving a value not defined in <<calendar>> to the **`calendar`** attribute; alternatively, the attribute may be omitted.

[[paleoclimate-time-axis-ex]]
[caption="Example 4.6. "]
.Paleoclimate time axis
====

----
double time(time) ;
  time:long_name = "time" ;
  time:units = "days since 1-1-1 0:0:0" ;
  time:calendar = "126 kyr B.P." ;
  time:month_lengths = 34, 31, 32, 30, 29, 27, 28, 28, 28, 32, 32, 34 ;
----

====

[[discrete-axis, Section 4.5, "Discrete Axis"]]
=== Discrete Axis

The spatiotemporal coordinates described in sections 4.1-4.4 are continuous variables, and other geophysical quantities may likewise serve as continuous coordinate variables, for instance density, temperature or radiation wavelength.
By contrast, for some purposes there is a need for an axis of a data variable which indicates either an ordered list or an unordered collection, and does not correspond to any continuous coordinate variable.
Consequently such an axis may be called {ldquo}discrete{rdquo}.
A discrete axis has a dimension but might not have a coordinate variable.
Instead, there might be one or more auxiliary coordinate variables with this dimension (see preamble to section 5).
Following sections define various applications of discrete axes, for instance section 6.1.1 {ldquo}Geographical regions{rdquo}, section 7.3.3 {ldquo}Statistics applying to portions of cells{rdquo}, section 9.3 {ldquo}Representation of collections of features in data variables{rdquo}.
